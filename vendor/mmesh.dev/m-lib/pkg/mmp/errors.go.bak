package slack

import (
	"encoding/json"
	"strconv"
	"time"

	"github.com/nlopes/slack"
	"x6a.dev/pkg/errors"
)

const (
	NotifyChannelInfo         = "nx-events-info"
	NotifyChannelWarning      = "nx-events-warning"
	NotifyChannelError        = "nx-events-error"
	NotifyChannelFatal        = "nx-events-fatal"
	NotifyChannelSecurityRBAC = "nx-security-rbac"

	NotifyColorInfo    = "#009999"
	NotifyColorWarning = "#fff000"
	NotifyColorError   = "#ff0000"
	NotifyColorFatal   = "#990000"
)

func SetSlackNotifyTo(userEmail string) errors.ErrOption {
	slackUserID, err := GetUserIDByEmail(userEmail)
	if err != nil {
		errors.Log(err)
	}

	return errors.ErrOption{
		Key:   errors.OptionNotifyTo,
		Value: slackUserID,
	}
}

func SlackErrorNotify(e *errors.Error) error {
	var evChannel, msgColor string

	switch e.Error.Severity {
	case errors.SeverityInfo:
		msgColor = NotifyColorInfo
		evChannel = NotifyChannelInfo
	case errors.SeverityWarning:
		msgColor = NotifyColorWarning
		evChannel = NotifyChannelWarning
	case errors.SeverityError:
		msgColor = NotifyColorError
		evChannel = NotifyChannelError
	case errors.SeverityFatal:
		msgColor = NotifyColorFatal
		evChannel = NotifyChannelFatal
	}

	slackChannelID, err := GetGroupID(evChannel)
	if err != nil {
		errSlack := errors.Wrapf(err, "[%v] function GetGroupID(evChannel)", errors.Trace())
		return errors.Wrapf(e.Err(), "%v", errSlack)
	}

	timestamp := time.Now()
	msgTitle := "[" + string(e.Error.Severity) + "] " + timestamp.Format(time.RFC3339) + ": " + e.Error.Type

	attachment := slack.Attachment{
		Title:      msgTitle,
		Text:       "```" + e.Error.Message + "```",
		Color:      msgColor,
		AuthorName: NxBot,
		AuthorIcon: NxBotIcon,
		Ts:         json.Number(strconv.Itoa(int(timestamp.Unix()))),
		Fields: []slack.AttachmentField{
			// slack.AttachmentField{
			// 	Title: "Trace",
			// 	Value: e.Error.Trace,
			// 	Short: false,
			// },
			{
				Title: "Type",
				Value: e.Error.Type,
				Short: true,
			},
			{
				Title: "Code",
				Value: strconv.Itoa(e.Error.StatusCode),
				Short: true,
			},
			{
				Title: "Priority",
				Value: string(e.Error.Priority),
				Short: true,
			},
			{
				Title: "Severity",
				Value: string(e.Error.Severity),
				Short: true,
			},
			{
				Title: "Timestamp",
				Value: timestamp.Format(time.RFC3339),
				Short: false,
			},
		},
	}

	if err := PostMessage(slackChannelID, attachment, MessageTypePrivateGroup); err != nil {
		errSlack := errors.Wrapf(err, "[%v] function PostMessage(slackChannelID, attachment, MessageTypePrivateGroup)", errors.Trace())
		return errors.Wrapf(e.Err(), "%v", errSlack)
	}

	for _, slackUserID := range e.NotifyTo {
		if err := PostMessage(slackUserID, attachment, MessageTypeDM); err != nil {
			errSlack := errors.Wrapf(err, "[%v] function PostMessage(slackUserID, attachment, MessageTypeDM)", errors.Trace())
			return errors.Wrapf(e.Err(), "%v", errSlack)
		}
	}

	return e.Err()
}
